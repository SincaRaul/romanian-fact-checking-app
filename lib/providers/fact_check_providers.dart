import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../data/fact_check_repository.dart';
import '../data/api_fact_check_repository.dart';
import '../data/fact_check_repository_interface.dart';
import '../services/api_service.dart';
import '../services/analytics_service.dart';
import '../models/fact_check.dart';
import 'onboarding_providers.dart';

// Configuration: toggle between mock and real API
const bool useRealApi = true; // Set to true when backend is ready

// API service provider
final apiServiceProvider = Provider((ref) => ApiService());

// Analytics service provider
final analyticsServiceProvider = Provider((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AnalyticsService(apiService.dio);
});

// Repository provider - switches between mock and real API
final factCheckRepoProvider = Provider<FactCheckRepositoryInterface>((ref) {
  if (useRealApi) {
    final apiService = ref.watch(apiServiceProvider);
    return ApiFactCheckRepository(apiService);
  } else {
    return FactCheckRepository(); // Mock repository
  }
});

// Latest fact checks provider (all fact-checks) - Get more for accurate statistics
final latestFactChecksProvider = FutureProvider<List<FactCheck>>(
  (ref) => ref.watch(factCheckRepoProvider).getLatest(limit: 1000),
);

// Personalized fact checks provider (based on selected categories)
final personalizedFactChecksProvider = FutureProvider<List<FactCheck>>((
  ref,
) async {
  final selectedCategories = ref.watch(selectedCategoriesProvider);
  final repository = ref.watch(factCheckRepoProvider);

  // If no categories selected, show all
  if (selectedCategories.isEmpty) {
    return repository.getLatest();
  }

  // Get fact-checks for selected categories
  return repository.getByCategories(selectedCategories);
});

// Fact check by ID provider
final factCheckByIdProvider = FutureProvider.family<FactCheck?, String>(
  (ref, id) => ref.watch(factCheckRepoProvider).getById(id),
);

// Search fact checks provider
final searchFactChecksProvider = FutureProvider.family<List<FactCheck>, String>(
  (ref, query) => ref.watch(factCheckRepoProvider).searchFactChecks(query),
);

// Fact checks by verdict provider
final factChecksByVerdictProvider =
    FutureProvider.family<List<FactCheck>, Verdict>(
      (ref, verdict) => ref.watch(factCheckRepoProvider).getByVerdict(verdict),
    );

// Auto-generated fact checks provider
final autoGeneratedFactChecksProvider = FutureProvider<List<FactCheck>>(
  (ref) => ref.watch(factCheckRepoProvider).getAutoGenerated(),
);

// Hot fact checks provider - trending/popular content
final hotFactChecksProvider = FutureProvider<List<FactCheck>>((ref) async {
  final apiService = ref.watch(apiServiceProvider);
  try {
    final response = await apiService.dio.get('/fact-checks/hot?limit=10');
    return (response.data as List)
        .map((json) => FactCheck.fromJson(json))
        .toList();
  } catch (e) {
    // Fallback to latest if hot endpoint fails
    return ref.watch(factCheckRepoProvider).getLatest();
  }
});

// Verdict statistics provider
final verdictStatisticsProvider = FutureProvider<Map<Verdict, int>>(
  (ref) => ref.watch(factCheckRepoProvider).getVerdictStatistics(),
);

// General statistics provider for homepage - uses dedicated endpoint
final homeStatisticsProvider = FutureProvider<Map<String, dynamic>>((ref) async {
  final apiService = ref.watch(apiServiceProvider);
  
  try {
    // Use dedicated statistics endpoint for accurate counts
    final response = await apiService.dio.get('/fact-checks/statistics');
    return Map<String, dynamic>.from(response.data);
  } catch (e) {
    // Fallback to counting from limited fact-checks if endpoint fails
    try {
      final allFactChecks = await ref.watch(latestFactChecksProvider.future);
      final autoGenerated = allFactChecks.where((fc) => fc.autoGenerated).length;
      final manual = allFactChecks.length - autoGenerated;
      
      return {
        'total': allFactChecks.length,
        'autoGenerated': autoGenerated,
        'manual': manual,
      };
    } catch (e2) {
      // Return fallback stats if both API calls fail
      return {
        'total': 0,
        'autoGenerated': 0,
        'manual': 0,
      };
    }
  }
});
