import 'dart:math';
import '../models/fact_check.dart';
import 'fact_check_repository_interface.dart';

class FactCheckRepository implements FactCheckRepositoryInterface {
  final _rnd = Random();

  Future<List<FactCheck>> getLatest() async {
    await Future.delayed(const Duration(milliseconds: 250));
    final v = [Verdict.true_, Verdict.false_, Verdict.mixed, Verdict.unclear];

    final mockTitles = [
      'Afirmație #1: „România are cel mai mare deficit bugetar din UE"',
      'Afirmație #2: „Vaccinurile COVID conțin cipuri de urmărire"',
      'Afirmație #3: „Energia regenerabilă este mai scumpă decât cărbunele"',
      'Afirmație #4: „5G cauzează cancer și alte boli"',
      'Afirmație #5: „Schimbările climatice sunt un mit inventat"',
      'Afirmație #6: „Economia României crește cu 7% pe an"',
      'Afirmație #7: „Hidroxiclorochina vindecă COVID-19"',
      'Afirmație #8: „UE vrea să interzică mașinile pe benzină până în 2025"',
    ];

    return List.generate(
      8,
      (i) => FactCheck(
        id: '${1000 + i}',
        title: mockTitles[i],
        verdict: v[i % 4],
        confidence: 50 + _rnd.nextInt(50),
        publishedAt: DateTime.now().subtract(Duration(days: i)),
        autoGenerated: i.isEven,
      ),
    );
  }

  Future<FactCheck?> getById(String id) async {
    await Future.delayed(const Duration(milliseconds: 200));

    // Simulate getting a specific fact check
    final verdictIndex = int.tryParse(id.substring(id.length - 1)) ?? 0;
    final verdicts = [
      Verdict.true_,
      Verdict.false_,
      Verdict.mixed,
      Verdict.unclear,
    ];

    return FactCheck(
      id: id,
      title:
          'Detalii pentru fact-check $id: „Afirmație detaliată pentru verificare"',
      verdict: verdicts[verdictIndex % 4],
      confidence: 60 + _rnd.nextInt(40),
      publishedAt: DateTime.now().subtract(Duration(days: _rnd.nextInt(7))),
      autoGenerated: verdictIndex.isEven,
    );
  }

  Future<List<FactCheck>> searchFactChecks(String query) async {
    await Future.delayed(const Duration(milliseconds: 300));
    final allChecks = await getLatest();

    final lowercaseQuery = query.toLowerCase();
    return allChecks
        .where((check) => check.title.toLowerCase().contains(lowercaseQuery))
        .toList();
  }

  Future<List<FactCheck>> getByVerdict(Verdict verdict) async {
    await Future.delayed(const Duration(milliseconds: 200));
    final allChecks = await getLatest();

    return allChecks.where((check) => check.verdict == verdict).toList();
  }

  Future<List<FactCheck>> getAutoGenerated() async {
    await Future.delayed(const Duration(milliseconds: 200));
    final allChecks = await getLatest();

    return allChecks.where((check) => check.autoGenerated).toList();
  }

  Future<Map<Verdict, int>> getVerdictStatistics() async {
    final allChecks = await getLatest();
    final stats = <Verdict, int>{};

    for (final verdict in Verdict.values) {
      stats[verdict] = allChecks
          .where((check) => check.verdict == verdict)
          .length;
    }

    return stats;
  }
}
