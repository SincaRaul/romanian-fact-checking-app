from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from app.db import get_db
from app import models, schemas
from app.services.gemini_service import gemini_service
from typing import Optional
from datetime import datetime
import uuid

router = APIRouter(prefix="", tags=["checks"])

@router.get("/fact-checks", response_model=list[schemas.CheckOut])
def latest_checks(
    db: Session = Depends(get_db), 
    limit: int = 20,
    category: Optional[str] = Query(None, description="Filter by single category"),
    categories: Optional[str] = Query(None, description="Filter by multiple categories (comma-separated)")
):
    query = (
        db.query(models.Check)
        .filter(models.Check.status.in_(["draft", "published"]))
    )
    
    # Add category filter if provided
    if categories:
        # Support multiple categories: "politics_internal,health,football"
        category_list = [cat.strip() for cat in categories.split(",")]
        query = query.filter(models.Check.category.in_(category_list))
    elif category:
        # Backward compatibility for single category
        query = query.filter(models.Check.category == category)
    
    rows = query.order_by(models.Check.created_at.desc()).limit(limit).all()
    return rows

@router.get("/fact-checks/statistics", response_model=dict)
def get_fact_check_statistics(db: Session = Depends(get_db)):
    """Get statistics for all fact-checks without limit"""
    # Count all fact-checks
    total_count = db.query(models.Check).filter(models.Check.status.in_(["draft", "published"])).count()
    
    # Count auto-generated fact-checks
    auto_generated_count = db.query(models.Check).filter(
        models.Check.status.in_(["draft", "published"]),
        models.Check.auto_generated == True
    ).count()
    
    # Count manual fact-checks
    manual_count = total_count - auto_generated_count
    
    return {
        "total": total_count,
        "autoGenerated": auto_generated_count,
        "manual": manual_count
    }

@router.get("/checks/{check_id}", response_model=schemas.CheckOut)
def get_check(check_id: str, db: Session = Depends(get_db)):
    c = db.query(models.Check).get(check_id)
    if not c:
        raise HTTPException(status_code=404, detail="Check not found")
    return c

@router.get("/categories", response_model=list[dict])
def get_categories():
    """Get all available categories with Romanian labels"""
    return [
        {"id": "football", "label": "Fotbal", "icon": "‚öΩ"},
        {"id": "politics_internal", "label": "PoliticƒÉ InternƒÉ", "icon": "üèõÔ∏è"},
        {"id": "politics_external", "label": "PoliticƒÉ ExternƒÉ", "icon": "üåç"},
        {"id": "bills", "label": "Facturi »ôi UtilitƒÉ»õi", "icon": "üí∞"},
        {"id": "health", "label": "SƒÉnƒÉtate", "icon": "üè•"},
        {"id": "technology", "label": "Tehnologie", "icon": "üíª"},
        {"id": "environment", "label": "Mediu", "icon": "üå±"},
        {"id": "economy", "label": "Economie", "icon": "üìà"},
        {"id": "other", "label": "Altele", "icon": "üì∞"}
    ]

@router.post("/generate", response_model=schemas.GenerateCheckResponse)
async def generate_fact_check(
    request: schemas.GenerateCheckRequest,
    db: Session = Depends(get_db)
):
    """Generate a new fact-check using AI"""
    try:
        # Generate fact-check using Gemini AI
        ai_result = await gemini_service.generate_fact_check(request.question)
        
        # Override category if user provided one
        if request.category:
            ai_result["category"] = request.category
        
        # Create a new Check record in database
        check_id = str(uuid.uuid4())
        
        # Create a dummy question first (since Check requires question_id)
        question = models.Question(
            id=str(uuid.uuid4()),
            title=request.question,
            body=None,
            status="published",
            votes_count=0,
            created_at=datetime.utcnow()
        )
        db.add(question)
        db.flush()  # Get the question ID
        
        # Create the fact-check
        new_check = models.Check(
            id=check_id,
            question_id=question.id,
            title=request.question,
            verdict=ai_result["verdict"],
            confidence=ai_result["confidence"],
            summary=ai_result["summary"],
            category=ai_result["category"],
            sources=ai_result.get("sources", []),
            auto_generated=True,
            status="published",
            published_at=datetime.utcnow(),
            created_at=datetime.utcnow()
        )
        
        db.add(new_check)
        db.commit()
        db.refresh(new_check)
        
        return schemas.GenerateCheckResponse(
            id=new_check.id,
            title=new_check.title,
            verdict=new_check.verdict,
            confidence=new_check.confidence,
            summary=new_check.summary,
            category=new_check.category,
            auto_generated=new_check.auto_generated,
            created_at=new_check.created_at,
            sources=new_check.sources
        )
        
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"Eroare la generarea fact-check-ului: {str(e)}"
        )

@router.post("/test-models")
async def test_different_models(request: schemas.GenerateCheckRequest):
    """Test different Gemini models for comparison"""
    try:
        from app.services.gemini_service import GeminiService
        
        # Test with different models
        models_to_test = [
            "gemini-2.0-flash-exp",
            "gemini-2.0-flash-thinking-exp", 
            "gemini-1.5-flash",
            "gemini-1.5-pro"
        ]
        
        results = {}
        
        for model_name in models_to_test:
            try:
                service = GeminiService(model_name=model_name)
                result = await service.generate_fact_check(request.question)
                results[model_name] = {
                    "success": True,
                    "result": result
                }
            except Exception as model_error:
                results[model_name] = {
                    "success": False,
                    "error": str(model_error)
                }
        
        return {
            "question": request.question,
            "models_tested": results
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"Error testing models: {str(e)}"
        )

@router.get("/user-analytics/{user_id}", response_model=dict)
def get_user_analytics(user_id: str, db: Session = Depends(get_db)):
    """Get analytics for a specific user"""
    try:
        from redis import Redis
        import os
        
        # Connect to Redis - use same config as analytics.py
        redis_host = os.getenv("REDIS_HOST", "redis")  # Changed from localhost to redis
        redis_port = int(os.getenv("REDIS_PORT", 6379))
        redis_db = int(os.getenv("REDIS_DB", 0))
        
        r = Redis(host=redis_host, port=redis_port, db=redis_db)
        
        # Get unique stories viewed (using HyperLogLog)
        stories_read_key = f"user_stories_read:{user_id}"
        stories_read_count = r.pfcount(stories_read_key) or 0
        
        # Get unique stories shared
        stories_shared_key = f"user_stories_shared:{user_id}" 
        stories_shared_count = r.pfcount(stories_shared_key) or 0
        
        # Get questions submitted
        questions_key = f"user_questions:{user_id}"
        questions_count = r.pfcount(questions_key) or 0
        
        return {
            "stories_read": stories_read_count,
            "stories_shared": stories_shared_count, 
            "questions_submitted": questions_count
        }
        
    except Exception as e:
        # Fallback to zeros if Redis is not available
        print(f"Redis error in user analytics: {e}")
        return {
            "stories_read": 0,
            "stories_shared": 0,
            "questions_submitted": 0
        }

@router.post("/fact-checks", response_model=schemas.CheckOut)
async def create_fact_check(
    request: schemas.CreateFactCheckRequest,
    db: Session = Depends(get_db)
):
    """Create a new fact-check manually"""
    try:
        # Create a new Check record in database
        check_id = str(uuid.uuid4())
        
        # Create a dummy question first (since Check requires question_id)
        question = models.Question(
            id=str(uuid.uuid4()),
            title=request.title,
            body=None,
            category=request.category,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        db.add(question)
        db.flush()  # To get the question ID
        
        # Create the check
        new_check = models.Check(
            id=check_id,
            question_id=question.id,
            title=request.title,
            verdict=request.verdict,
            confidence=request.confidence,
            summary=request.summary,
            category=request.category,
            sources=request.sources,
            auto_generated=False,  # Manual creation
            status="published",
            created_at=datetime.now(),
            updated_at=datetime.now(),
            published_at=datetime.now()
        )
        
        db.add(new_check)
        db.commit()
        db.refresh(new_check)
        
        return new_check
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to create fact-check: {str(e)}")

@router.post("/fact-checks", response_model=schemas.CheckOut)
def create_fact_check(
    request: schemas.CreateFactCheckRequest,
    db: Session = Depends(get_db)
):
    """Create a new fact-check manually"""
    try:
        # Create a new Check record in database
        check_id = str(uuid.uuid4())
        
        # Create a dummy question first (since Check requires question_id)
        question = models.Question(
            id=str(uuid.uuid4()),
            title=request.title,
            body=None,
            status="checked"
        )
        db.add(question)
        
        # Create the fact-check
        check = models.Check(
            id=check_id,
            question_id=question.id,
            title=request.title,
            verdict=request.verdict,
            confidence=request.confidence,
            summary=request.summary,
            category=request.category,
            sources=request.sources,
            auto_generated=False,  # Manual fact-check
            status="published",
            published_at=datetime.utcnow()
        )
        db.add(check)
        db.commit()
        db.refresh(check)
        
        return check
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error creating fact-check: {str(e)}")
